webpackJsonp([0xac9f961a6be4],{421:function(n,s){n.exports={data:{site:{siteMetadata:{title:"EVLE",subtitle:"Knowledge is not consumed, it is shared",copyright:"© All rights reserved.",author:{name:"evle",twitter:"#"},disqusShortname:"",url:"https://evle.netlify.com"}},markdownRemark:{id:"/Users/evle/blog/src/pages/articles/2020-01-25---koa-source/index.md absPath of file >>> MarkdownRemark",html:'<p>[toc]</p>\n<p>很久没有看express源码了, 温故知新, 现在时间充足可以将express的核心源码实现一遍, 说起express不得不提Koa, \b本篇文章将回顾Koa的核心实现, 以及与Express做一个对比。</p>\n<h2>文件结构</h2>\n<p>看Koa和Express的源码可以看出他们最明显的区别是: Koa使用ES6语法实现, 而express还是ES5的语法, Koa的核心文件只有四个</p>\n<ul>\n<li>application.js</li>\n<li>request.js</li>\n<li>response.js</li>\n<li>context.js</li>\n</ul>\n<p><code class="language-text">applicatoin.js</code>是Koa的核心, 比如监听http端口, 处理中间件。<code class="language-text">request.js</code>和<code class="language-text">response.js</code>则是对\b原生http的request和response做扩展, <code class="language-text">context.js</code>提供了<code class="language-text">ctx</code>对象, 算是Koa与Express的第二个区别点, 当收到Http Incoming请求的时候, Koa将request与response包装在了<code class="language-text">ctx</code>对象中, 并且提供了很多便利的操作方式, 而Express则是使用原生的requeset与response对象, 并且对其进行了扩展。</p>\n<h2>ctx对象的实现</h2>\n<p>在Koa中, 我们的request handler会被传入一个ctx对象来简化我们的操作, 比如我们当取得request的<code class="language-text">url</code>属性, 我们可以使用以下4种方式</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">ctx<span class="token punctuation">.</span>req<span class="token punctuation">.</span>url\nctx<span class="token punctuation">.</span>request<span class="token punctuation">.</span>url\nctx<span class="token punctuation">.</span>request<span class="token punctuation">.</span>req<span class="token punctuation">.</span>url\nctx<span class="token punctuation">.</span>url</code></pre>\n      </div>\n<p><code class="language-text">ctx.req</code>是原生的request即</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token function">_createContext</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">let</span> ctx <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>\n  ctx<span class="token punctuation">.</span>req <span class="token operator">=</span> req<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> ctx<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>所以我们可以拿到原生request的<code class="language-text">url</code>属性通过<code class="language-text">ctx.req.url</code>, 但是<code class="language-text">ctx.request</code>中的<code class="language-text">request</code>只是一个普通的对象来自<code class="language-text">request.js</code>并没有<code class="language-text">url</code>属性, 那改如何拿? Koa使用了对象的getter方法, 通过getter返回<code class="language-text">this.req.url</code>, 通过 this拿到了this.req.url</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> request <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token keyword">get</span> <span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>req<span class="token punctuation">.</span>url\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nmodule<span class="token punctuation">.</span>exports request<span class="token punctuation">;</span>\n\nctx<span class="token punctuation">.</span>request<span class="token punctuation">.</span>url <span class="token comment">// this指向了ctx</span></code></pre>\n      </div>\n<p><code class="language-text">ctx</code>对象中还有一个重要的属性是<code class="language-text">body</code>, 通过给<code class="language-text">body</code>赋值可以响应给浏览器结果, body来自<code class="language-text">context.js</code>, 也是一个普通对象, 通过getter和setter设置内部的body属性</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>\n  _body<span class="token punctuation">:</span> undefiend<span class="token punctuation">,</span>\n  <span class="token keyword">get</span> <span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_body\n  <span class="token punctuation">}</span>\n  <span class="token keyword">set</span> <span class="token function">body</span><span class="token punctuation">(</span><span class="token parameter">body</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_body <span class="token operator">=</span> body\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>每当中间件对<code class="language-text">ctx.body</code>赋值, 其实就是对context内部的_body赋值, 等待所有中间件执行完毕的时候\b来根据<code class="language-text">ctx.body</code>的值来响应客户端。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> ctx<span class="token punctuation">.</span>body <span class="token operator">===</span> <span class="token string">\'string\'</span> <span class="token operator">||</span> Buffer<span class="token punctuation">.</span><span class="token function">isBuffer</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// 返回字符串 设置响应头 </span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> ctx<span class="token punctuation">.</span>body <span class="token operator">===</span> <span class="token string">\'object\'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// 返回json 设置响应头 </span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> ctx<span class="token punctuation">.</span>body <span class="token keyword">instanceof</span> <span class="token class-name">Stream</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// 返回流 设置响应头 </span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> ctx<span class="token punctuation">.</span>body <span class="token operator">===</span> <span class="token string">\'undefined\'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// 设置状态吗204 No Content</span>\n  <span class="token punctuation">}</span></code></pre>\n      </div>\n<h2>中间件的实现</h2>\n<p>中间件是Express和Koa的核心特性, 但实现却完全不同, Koa的中间件由是基于Promise实现的, 配合<code class="language-text">await</code>写代码很舒服, 而Express则是使用<code class="language-text">callback</code>实现的, 比如如果要统计一个中间件的处理时间, 那么用Koa很简单, 只要在中间件前后计算中间差即可, 但是Express实现同样的需求必须重写<code class="language-text">res.end</code>方法, Express的中间件是基于路由的, 也就是对路由有强依赖, 但是Koa的中间件实现很简单, 就是一个递归调用所有的中间件  </p>\n<p>首先通过<code class="language-text">use</code>来注册中间件3个中间件, 需要注意2个点, 一是<code class="language-text">await</code>\b\b只会等待Promise，因为所有的异步操作需要封装成Promise, 比如<code class="language-text">sleep</code>, 另一个需要注意的点是我们不知道下一个中间件是同步还是异步任务, 所以统一使用<code class="language-text">await next()</code>来确保中间件的执行顺序正确。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\napp<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\napp<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n  <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span> <span class="token comment">// 异步任务需要封装成 Proimse</span>\n  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\napp<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>\n  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>注册中间件之后, 需要递归的遍历这些异步中间件</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> <span class="token function-variable function">dispatch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> middleware <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">middleware</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> dispatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>通过上面的简单实现我们可以看到, Koa在处理中间件时是如果遇到<code class="language-text">next</code>则将控制权交给下一个中间件, 等下一个中间件执行完且没有next, 才开始返回, 执行next()之后的代码。而Express则是一个接着一个执行。</p>\n<p>此外, Koa和Express对中间件中的错误捕获处理也完全不同, Koa继承了<code class="language-text">events</code>, 可以在全局监听一个<code class="language-text">error</code>事件, 当<code class="language-text">try..catch</code>到的异步错误被捕获后, 使用<code class="language-text">emit</code>发送错误即可。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'error\'</span><span class="token punctuation">,</span> <span class="token parameter">e</span><span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">dispatch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> middleware <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">try</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">middleware</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> dispatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">\'error\'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>Express在捕获错误的时候相比Koa复杂, 如果有中间件发生错误时则在调用<code class="language-text">next(err)</code>即给next参数error参数, 如果检查到next中有参数的话, 则会停止运行后面的中间件, 直接跳到有4个参数的中间件且第一个参数是error的错误处理中间件来执行。</p>\n<h2>总结</h2>\n<p>本文通过对实现了一个Koa核心功能进行了梳理, 并且与Express对比得到以下结果:</p>\n<ul>\n<li>Koa使用ES6语法, Express使用ES5</li>\n<li>Koa中间件执行时遇到next会执行下一个中间件,等下一个执行完在返回继续执行, Express中间件会一个接一个执行</li>\n<li>Koa\b\b捕获中间件错误通过try…catch捕获, 并且通过事件通知错误, 而Express则是通过给next传递error参数, \b使用错误处理中间件来捕获中间件错误</li>\n<li>Koa中间件使用Promise实现, Express则是使用回调函数。</li>\n</ul>\n<p>\b\b\b\b</p>',fields:{tagSlugs:["/tags//"]},frontmatter:{title:"从Koa核心功能实现对比与Express的区别",tags:[null],date:"2020-01-25",description:""},excerpt:"toc 很久没有看express源码了, 温故知新, 现在时间充足可以将express的核心源码实现一遍, 说起express不得不提Koa, \b本篇文章将回顾Koa的核心实现, 以及与Express做一个对比。 文件结构 看Koa和Express…"}},pathContext:{slug:"/posts/koa-source"}}}});
//# sourceMappingURL=path---posts-koa-source-ec2e1d4a0a36eaa11bdb.js.map